
Custom application configration for containerized images:
  ConfigMap:
    A k8s Object to seprate configuration from Pods
    It stores the configuration data in Key/value pairs within ETCD database
    Configuration Files
    Command Line Arguments
    Environment Variables
    
    But the sensitive data, will be managed using Secrets.
    ConfigMap should be created before referencing in the Pod spec 
    
kubectl create configmap <map-name> <data-source>

<data-source>|-
  -from-file directory or file name 
  --from-literal Key/value pair
  
kubectl get configmaps <map-name> -o wide|yaml
kubectl describe configmap <map-name>
  
Example - manifest:

apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
    - name: redis-container
      image: redis/redis:latest
      volumeMounts:
        - name: config
          mountPath: /redis-master
  volumes:
    - name: config
      configMap:
        name: my-config-map
        items:
         - key: redis-config  # file name from the config-map
           path: redis.conf

kubectl create -f redis-pod.yaml
kubectl exec redis cat /redis-master/redis.conf

========================================================

ConfigMap for Literal Values:
  kubectl create configmap literal-map --from-literal=my.key=value
  kubectl get configmap literal-map
  
  Reference the literal Key/values
  
  apiVersion: v1
  kind: pod
  metadata:
    name: map-pod
  spec:
    containers:
      - name: busy-box-test
        image: busybox
        command: ["/bin/sh", "-c", "env"]
        env:
          - name: CUSTOM_KEY
            valueFrom:
              configMapKeyRef:
                name: literal-map
                key: my.key
    restartPolicy: never  # never restart the pod
    
  kubectl create -f my-busy-pod.yaml
  kubectl logs map-pod
  
  ==========================================
  
  K8s - DeamonSet
    To control that all or some nodes of the cluster runs a copy of the Pod
    Example: An application instance per instance on all the nodes in the cluster or subset of nodes, even when the cluster is scaling
    Subsets - can be applied with the help of node labels. 
    Typical UseCases?
      Storage Deamons: ceph
      Log collection Daemon: fluentd
      Node monitoring deamon: collectd
      
Example manifest file:

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: custom-ds
  labels:
    tier: daemons
spec:
  template:
    metadata:
      labels:
        app: fluentd   # to be used in the selector section
    spec:
      containers:
        image:
          - name: fluent-container
            image: gcr.io/google-containers/fluentd-elasticsearch
  selector:
    matchLabels:
      app: fluentd
  
kubectl create -f custom-daemon-set.yaml
kubectl get po -o wide
kubectl get ds
kubectl describe ds custom-ds
ubectl delete ds custom-ds   # make sure to delete the daemonset not pods
===============================================
