
What containers brings to Us?
  1) Protability
  2) High boot up time 
  3) Lower resource requirements when compared to VM
  4) Easy deployment 
  5) Software virtualization over h/w virtualization
  6) Isolation 
  7) Easy scalability and orchestration
  
  Upgrades with Zero downtime, Sequentionally, pause, resume, rollback.
  
  Container Orchestration Engine - K8s?
    To automate deploy, scale and manage containerized applications on group of servers
    
      Fault tolerant 
      Availabililty 
      Scalability - in, out, up and down
      Clustering
      Scheduling
      Loadbalancing
      Deployment and rollout or canary

Advanced:
    Service Discovery
    Monitoring 
    Secrets managements

Borg - Propprietry container manager of Google

============================================
Creating A K8s cluster:
  Max. 5000 Nodes per cluster
  - Worker nodes[Minions] are the VMs or physical machines where the actual images are deployed
  - Master - Contoller that supports features for user and worker nodes
  - Pods - In most cases we see one containers per pod but it can have more containers
  - Containers - runtime environments that serve world
  
Master:
  1) API server - gateway of entire cluster, to view and review the metadata though APIs.
    How, kubeclt or UI or other ways to invoke APIs
  
  2) Scheduler - scheduling pods for workers
  
  3) Control manager - 
    Nodes are running, orchestration
  
    a) Node controller
    b) Duplication controller
    c) Service account and Endpoint controller
    d) End point controller
  
  4) etcd - Key/Value database to store the metadata and runtime state of cluster


Worker nodes:
 An VMs or physical server that runs the container on runtime environment E.g. Docker or Rocket[RKT]
 a) Kubelet Agent - node agent to monitor PODS and makesure they are healthy. To restart the nodes
 b) Kube proxy - Distrubted n/w manager across all the nodes, pods, containers. 
 c) Runtime container 
 d) Pod - Each POD contain one or more container.

=============================================

Deployments::
  a) Replicas (Scale in or Out) - defaults:1 - atleast one Pod is running at single point in time.
  b) Upgrade - 
  c) Rollback - 
  d) Scale Up or Down - 
  e) Pause and resume - 

Types:
  1. Recreate - Downtime is allowed, when switcting from V1 to V2
  2. Rolling  update[Default] - Incremental, change to all the Pods
  3. Canary - Gradual shift from V1 to V2
  4. Blue/Green - Both the version are deployed and a traffic switch is done at the LB level.
  
  Sample manifest file:
  
   apiVersion: api/v1
   kind: Deployment
   metadata:
     name: redis
     label:
       app: redis
   spec:
     replicas: 3
     selector:
       matchLabels:
         app: redis  
     
     template:
       metadata:
         labels:
           app: redis

      spec:
        containers:
          - name: redis
            image: redis:latest
            ports:
              - containerPort: 6379

===========================

kubectl create -f redis-deploy.yml
kubectl get deploy // get deplyment
kubectl get rs  // Get replica ser
kubectl get po  // Get pods
kubectl describe deploy redis

1) Using kubectl
kubectl set image deploy redis redis-container=redis:5.0.6 --record // Upgrade with --record to track history
2) Edit deployment file
kubectl edit deploy redis

kubectl rollout status deployment/redis
kubectl get deploy // get deplyment

kubectl rollout history deployment/redis

Rollback:
kubectl rollout undo deployment/redis
kubectl rollout status deployment/redis


Scale up or Down:
  kubectl scale deployment redis --replicas=5
  
  kubectl scale deployment redis --replicas=3

Delete deployment:
kubectl delete -f redis.yml

==========================================================

Handson:

Minikube -> A utility to test Kubernetes as standalone system. Which includes K8s master and Worker nodes
Kubeadm -> A utility to setup K8s cluster in realtime. 















