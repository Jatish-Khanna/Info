The most important feature Java 9 has brought into market is "Modularization"

Java platform updates-
  Module System 
  JShell
  
Library Features-
  New factory methods in Collections framework
  Stream API enhancements
  Process API
  HTTP/2.0
  Compact Strings
  Enhancement of @Deprecated annotation
  
  
Java language Features-
  New try-with resources
  Private methods in interfaces
  @SafeVarargs on private instance methods
  Diamond Operator with Anonymous classes
  
JVM -
  Garbage collection
  
  =======================
  JPMS - Java platform module system
    * JDK/JRE the rt.jar is too big for the modern day infrastructure like IoT devices
    * Weak encapsulation?
      A package exposes all its public types to other packages and no way to prevent the global visibility
      No encapsulation above the packages, not even by Jars 
    
    
   Actual specification from JSRs
   1. JEP 261 - Create a module system for the language
   2. JEP 220 - Update the runtime to support modularity
   3. JEP 201 - Modularize JDK source
   4. JEP 200 - Modularize the JDK libs
   5. JEP 260 - Encapsulate most internal API's 
   6. JEP 282 - Create smaller runtime with subset of modules from JDK
   
   
   Why modularity?
   * Ease of support of runtime for different h/ws
   * Maintenance and reusability 
   * Improved performance, startup time and memory usage of applications
   
   Platform modules-
     1. Standard modules -
       The name of these modules starts with java.*
       These are supported and intended to be used by developers
       
       
       Example-
       java.rmi.*
       java.log.*
     
     2. Non-standard modules - 
       The name of these modules start with jdk.*
       Non-standard modules contain packages and specific JDK code, distinct b/w implementations of JDK
       
   How to identify and describes the modules?
     java --listmodules
     java --describe-module <MODULE_NAME>
     
     
  ===========================
  Module - An encapsulated package having self-describing code and features
    module-info.java provides details of packages, resource files,
      * The module descriptor file that specifies behaviour and accessibility
      
      - A unique name of the module (which can only be used by other modules to access it)
      - A list of other modules it requires
      - List of packages that it exports to other modules
      - A list of services it uses
      - a list of service implementation it provides
      
      
      
   Contents of module-info.java
   
   module com.module.name { }
   
   Looking at Above code in module-info.java, the package structure should be like-
   
   Project_name|
                |__com.module.name|
                                  |_____packages
                                  |
                                  |_____module-info.java
   
   
   How to Compile the completed Project?
     javac -d output --module-source-path .
   
    -d <OUTPUT_PATH_FOLDER> : The compiled files will be stored at the specified path
    --module-source-path specifies the location containing source files for multiple modules
    
    
    Funny! can you execute the Program?
      java -p <OUTPUT_PATH> -m <MODULE_NAME>
      
      -m specifies the module name where main class resides
   
   
   Module accessibility?
   Main Module-
   ---------
   exports - to expose the specific package from the modules
   
   module com.module.name {
      exports com.module.name;
    }
   
   Other Modules
   ---------------
   requires specifies the module it depends on
   
   
   module com.module.requires {
    requires com.module.requires;
  }
   
====================
Policies on Modules?
  When a module requires another modules-
  . Module First should mention the package required
  . Module Second should export the package required by module First
  . The types in the exported package must be public
  
  Controlling what module requires and what module exposes defines the encapsulation at package level
  ------------------------------------------
  
  Module readability?
  
  1. requires transitive X - if module Y reads X module, all other modules which require module Y will be able to read X. 
  2. export package to X - export the package named "package" only to module X
  
  
  
  
  
  
  
  
  
  
  
  
  
   
   
   
  
  
  
  
  
  
  
  
  
  
  
  



