
In monolithic - the session has been generated by application which authorizes user to execute/request server for services

In microservice- in an enterprise scenario, all the request has been offloaded at API gateway (security is important for that)

  in addition to that-
    . An authorization to be done when service communicate with each other
   
   ===============================================
   
 First and Most important - sercure Zuul Server?
  1. Add the dependency at the Zuul microservice
  
  <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-security</artifactId>
</dependency>

2.  Mark the security is enabled for ZuulServer

@EnableOAuth2Sso
@EnableZuulProxy


 3. Add the OAuth provider information
 
 client:
    clientId: <>
    clientSecret: <>
    accessTokenUri: <>
    userAuthorizationUri: <>
    clientAuthenticationScheme: form
resource:
    userInfoUri: <>

===============================================

1. Add the dependency

<dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-security</artifactId>
</dependency>

2. Add @EnableResourceServer  annotation to all the microservices application file


3. Configuration-

client:
    accessTokenUri: <>
    userAuthorizationUri: <>
resource:
    userInfoUri: <>


Good now we have sercured the individual microservice

is securing individual microservice sufficient?
  Challenges-
  . The authentication header from Zuul or API gateway doesn't get forwarded inter-communication b/w microservices
  . It has to be done programmatically using the restTemplate
  
  ==================
  
  How to programmatically forward the request to restTemplate
  
  @Autowired
  RestTemplate restTemplate;
  
  @GetMapping("/service/{id}")
  public T getService(@RequestHeader HttpHeaders httpHeaders, @Pathvariable int id) {
  
    // The Header information to be exchanged b/w microservices
    HttpEntity<String> entity = new HttpEntity<>(httpHeaders);
    // ReponseEntity has the relevant headers and Entity information
    ResponseEntity<T> responseEntity = restTemplate.exchange("http://EUREKA_SERVICE_NAME/"+id, HttpMethod.GET, entity,List.class);
  }





============================

Secure application using Basic or Spring starter security

1. Add the dependency

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
</dependency>


  2. Add the username and password details in application.properties/yml
  
  spring.user.name=<>
  spring.user.password=<>
  
  Walaaa! The application is secured with Basic authentication
  
  
  How to access the application services programmatically
  
  http://USERNAME:PASSWORD@HOST_NAME:PORT
  
  
=================================

Problem#2 - Encrypt the private/sensitive information stored in VCS(Git) as the information available in public repository

Solution-
  1. Encrypt while storing the values in public repository
  2. Decrypt using Config server to use the values
  3. Decrypt using the individual microservice
  
  An example to use symmetric encryption@ Cloud Config Server

bootstrap.properties
  encrypt.key=<>
    
  Send a POST message to Config server service:port/encrypt
  
  Replace the encrypted value with plain text and append {cipher}<ENCRYPTED_VALUE>
  
  
Problem: like encrypt @Cloud config server has service "decrypt"
 
  How you can secure it?
    Note: Refer above Secure application using Basic or Spring starter security
  







