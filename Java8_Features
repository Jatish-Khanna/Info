The Java SE 8 Features 


Write interfaces with default and static methods

Apply Repeating Annotations

Work with Date/Time API

Develop Functional Interfaces

Apply Lambda Expressions

Work with Streams API

Make use of Optional class

Nashorn JS API

Spliterator

Type	Functional Interface	Abstract Method	Description
Function	Function<T, R>	R apply(T t)	
Function that accepts single argument and produces result  

Predicate	Predicate<T>	boolean test(T t)	Boolean-valued function that takes single argument
Consumer	Consumer<T>	void accept(T t)	Function that accepts single argument but returns no result
Supplier	Supplier<T>	T get()	Function that denotes a supplier of results




Summary of maven targets
Reporting and Tool Plugin
Description
checkstype

It creates a checkstyle report for the project

javadoc

It generates Javadoc report for the project

project-info-reports

It generates standard project reports for project

surefire-report

It generates results report for  unit tests in project

help

It retrieves information about the deployable environment of the project




----------------------------------------------

What are the benefits of multiple features in Java-8
 - Support for functional programmaing by Lamda and streams
 - Ease of high volume data processing by streams
 - Ease of use by getting parameter names by reflection
 - Reusable code with enhanced Collections API
 - Smart Exception handling with Optional
 - Encryption with Base64
 - Nashorn engine support for JS
 
Lambda Expression?
  It is an anonymous function
  The method that doesn't need accessmodifiers, name or return value
  This can be passed as paramter in a method
  Code as data - by passing as function parameter
  
  
Parts of Lambda expression?
  Paramter list (optional)
  Lambda arrow operator (separates listed params and expression body)
  Lambda expression body (the code that will be executed)
  
Lamda expression datatype?
  Lamda expression fullfills the purpose of passing as code
  The datatype of Lamda expression is a functional interface
  It is functional interface
  
- Functional programming
- Big data [With increase in database size]
- Optional [borrowed from Google guava lib, edge cases have been handled properly]
- Cloud computing [Code as data and code can be executed on multiple servers]
  
  
Why lambda expression?
 - Functional programming [One function is running the code of other function]
 - Cloud computing [Method as a param to other method, code as data]
 - Serverless architecture []
 
Why Functional Interfaces?
  - A functional interface that has abstract method
  Runnable, Callable interface
  
SAM - Single Abstract Method
  It has exactly one abstract method
  @FunctionalInterface : It is not mandatory to use [but it will ensure that interface has only SAM]
  

Used in Lamda expressions, method reference or constructor interface
- Code can be considered as data
- Functional has one abstract method, that has been passed as an argument method


 
Collection[Java 1.2] and Stream API[Java 8]:
 Collection is used to store data in different data structure
  Stream is used to apply computation or processing of data
 
 Collection is a finite set of data
 Stream is an infinite number of data
 
 Collection create objects in eager
 Stream initialize objects in lazy way
 
 Collection support iterate and consume multiple time
 Stream consumption is donen only once
