MongoDB performance - a mission critical infrastructure
 It is a high performance DB, 
  
  - Memory - quintessential resource
    It has storage engines that are very dependent on RAM for datamanagement operations
     e.g. Aggreation Pipelines, Index traversing, Writes in RAM first, Query engine, Connections ...
  
  The more the RAM, the more performant MongoDB will be
  
  - CPU
    * Concurreny Model, uses max CPU cores possible
   E.g. Map reduce, Page compression, Aggregation operations, data calculation
  
  - I/O
  All write and read operations are non-locking
  Single document updates doesn't help with performance as it locks the document for underlined updates
  
  Data persistance is done on Disk, the faster the disks are - affects the performance of MongoDB ()
   E.g HDD, EBS, SSD
  
  The best RAID architecture for MongoDB is - RAID 10, 
    and RAID 0 [only for write operations]
   -----------------------------
   
  mongoDB is a distributed database - with a sharing cluster it can easily scale horizontally
  Write Concern, Read Concern, Read preferences are taken into consideration when analyzing the performance of application
  
  ----------------------------
  
  1) Indexes ?
    To imporve the slow queries and responses from MongoDB by enhancing the Collection scan
   
   _id is automatically indexed by MongoDB
   BTree are used to store the indexes
    - Each new Insertion may not be an extra comparison in BTree
   
   Problem with Index - Index Overhead?
     A new document or remove or changed, will have to change the BTrees
   
 -------------------------------
 
 How Data is stored on a Disk in MongoDB ?
   Database - A logical group of collections
   Collection - operation units that group documents
   Index - over the Collection
   Document - Atomic unit of information
   
   
   The File Structure - 
     * For each Collection a separate file has been created
     * For each Index a seperate files has been created by MongoDb
     
     _mdb_catalog.wt - Catalog of all the different Collections and indexes
     
  a) mongod --dbpath . --fork --logpath /var/log/mongo
    - A simple mongo instance will be started with a DB files created in current directory
    
  b) mongod --dbpath . --fork --logpath /var/log/mongo --directoryperdb
    An additional option --directoryperdb, creates a new directory for each database instance
    
    - Inserting a document will create a single collection file and index for the collection in DB directory
  
   Note: admin and local are default databases, created by MongoDB
   
  c) mongod --dbpath . --fork --logpath /var/log/mongo --directoryperdb --wiredTigerDirectoryForIndexes
     A different organation, with an individual directory per Collection and a single directory for Indexes
   
 But Why you think is Important Creating such different Structures?
   Quitessential answer would be, PERFORMANCE
     - An I/O parallelization can be achieved by mounting the physical drives over servers
      As only DS used are collections, and Indexes
      
    Positively impacting the performance, throughput of persistency layer
    In addition to that, MongoDB allows the compression of disks 
   
   Note:
     MongoDb writes data first to memory and then synchronized/writen to any persistency layer
     The operation is triggered by two ways- 
     
     a) WriteConcern -  [User Side]
       db.collection.insert({...}, {writeConcern :  {w:3} })
     
     b) Preodically internal process, i.e. Sync period
   
Journal acts as safeguard againt data corruption, caused by unexpected failure.
 - The data stored in journal to recover the data
 - To minimize the performance impact of Journal, it writes the document in grouped formats [Group flushes]
 - All writes are atomic, to ensure consistency of Journal file
       db.collection.insert({...}, {writeConcern :  {w:3, j:true} })
 
 - From application perspective Journals can be enforced to synch data before ACK the write using "j: true"  in writeCONCERN

-------------------------------------

Types of Indexes ?
 1) Single Field index - the simplest of all types
   * That captures just keys on single field
   * The keys are only from One field
   * Can find a single value for the Index
   * can find a rangle of values
   * Can use dot notation to index fields in subdocuments
   * To find distinct value in a query
 
 Step-1
   db.collection.find({...}).explain("executionStats")
    - Extra information about the query
 *Analyze the Execution stats from the response

 Step-2 
  Create an index over the column searcher to retrieve data from the MongoDB collection
  db.collection.createIndex({column1: 1})
  // An index will be created by MongoDB over the Column
  
  Creating an Index means- 
    * Pulling data of particular column from Each document in the database
    * If the field is not present making a key/entry as NULL
  
  Step-3
    Repeat step-1 and analyze the executionStats esp.
    
    nReturned - number of document returned by the search query
    totalKeysExamined - number of Keys looked up by Query engine
    totalDocsExamined - number of documents from the complete collection pulled
    winningPlan.inputStage.stage - would be index scan (IXSCAN) instead of Collection scan (COLLSCAN)

Imapct of Indexes on Sorted Data?
  Sorting can be done -
  a) In memory -
    The stored documents are retrieved from the disk into RAM
    An algorithm has been executed on the data to be sorted in Memroy
      
  b) Using index -
    If Query is using an Index Scan [check executionStats], the documents retured are guranteed to be sorted by Index keys
    
    - No need to perform an Explicit sort
    - 

-------------------------------------------

2) Compound Indexes?
  A compound index is an index on Two or More fields
  In MongoDB - indexes are BTrees, and ordering is flat
  - Index keys are ordered list
  
 Index Prefixes?
    For a Compound index the Order matters as a prefix
    {col1 : 1,  col2 : 1, col3 : 1}
    Where only possible prefixes are - 
    {col1 : 1}
    {col1 : 1, col2 : 1}

If we're querying DB can use both Compound index and its prefix to serve the query
but it won't use any indexes other than compound or it's prefixes

Note: 
  not even a subindex like {col1 : 1, col3 : 1} can be used, here only allowed index prefix is {col1}
  Ordering of fields does matter when creating a compound index, 
    if Order of keys in filter/find is different than used in compound index, no such index will be used
    E.g. {col2 : 1, col1 : 1} is not allowed as prefix index

Example - 
 Looking for data only using col2 with the created compound index, won't utilize the specified compound index.
 
-----------------------------------------------

Sorting with Compound indexes ?
   The keys specified in Compound index doesn't necessarly uses the index while looking/finding document
    based on filter criteria specified
    
  The best thing to do is- create an index such where query search and sort can use the index/prefix of compound index
  E.g.
   find({col1 : "val", col2 : "val2"}).sort({col3 : 1})

The above example makes a quality condition, as the order of filter and sort makes a quality index/prefix

---------------------------------------------------
Sort Direction with Compound Indexes?
  The direction matters when creating compound Indexes
  - If the direction of Index is opposite to direction of sort for keys other than first, will perform in-memory sort
   As the data indexed is in reverse order

--------------------------------------------------

Multi-key Indexes?
  - We can have nested documents like -
   root : {
    subdoc : [
      {f1 : val1}.
      {f1 : val2}
    ]
   }

  db.collection.createIndex({root.subdoc.f1 : 1})

 - We can also create index on the array
  {
   root : [val1, val2]
   }

db.collection.createIndex({root : 1})

  Note: here index keys will be created on all the values of the array
    Creating a compound index on Two fields of one which is an array will create a huge Cartesian product of both the arrays
  
  Creating an Index on parallel arrays will fail with the Exception as "CannotIndexParallelArrays"
  
  --------------------------------------
  
  Partial Indexes ?
    To index a portion of documents in a collection
    Index a subsetof document takes advantage of lower cost for storage and maintenance it
    
    Example:
    
    root : {
      f1: v1,
      f2 : v2,
      
      subdocument: {
        s1 : v3,
        s2 : v4
      }
    }
    
  db.collection.createIndex( {
    {f1 : 1},
    
    { partialFilterExpression : {s1 : {$gt : 5, $lt : 10}}}
  })
  
  // Compound index with f1 fiels and s1 with value in range 5 - 10 exclusive
  // Partial indexes are useful for multi-key indexes such as indexing only few values in the array
  
  Note: It is important to frame the query for Partial indexed in which 
    Query must be guranteed to match a subset of the documents, specified by the filter expression of Index
    The reason to above is, server could miss results in case matching documents are not indexed
     
     ** Shard Key cann't be the partial Index
------------------------------
  Sparse Indexes ? 
  
   Both Partial and Sparse indexed cann't be used at same time
  
    These are special type of partial key indexes,
     sparse indexes where the field exists that we're indexing on
     Rather than, creating an index key with NULL value
     
     This same can be done with the Partial indexes as
     
     db.collection.createIndex(
       {f1 : 1},
       {sparse : true}
     )
     
  OR
  
  Emulation of Sparse index with the Partial Index...
  
    db.collection.createIndex(
     {f1 : 1},
     {partialFilterExpression : { f1 : {$exists : true }}}
    )
  Note: The Partial index gives you additional privlege of 
    - Expressing the query and constraints better than sparse Index
    - It helps you to verify the fields other than fields indexes on
  
  ---------------------------------------
  
  Text Indexes ?
    The option to using the Regular Expression when searching through documents.
    Regular expressions has performance disadvantages while searching a subtext/substring from MongoDB text field
    
    db.collection.createIndex({ f1 : "text"})
    // Rather than passing the field as ASC or DESC, here index specifies the type to be "text"
    
   How to levrage the MongoDB text search features?
     db.collection.find({$text {$search : "value"}})
  This avoid colection scan where as this is similar to multi-key indexes
  
  Note: Unicode considers " " and "-" as text delimiters, to make tokens out of full text string
  // Default: Text-indexes are case insensitive, 
  
  Note:
   Text indexes delimit each word and "OR" each delimited word
   
   db.collection.find(
   {
     $text: {
      $serach : "Token1 token2"
     },
     {
      "calculatedDocumentScore" : {$meta : "textScore"}
     }
   }
   )
  
  calculateDocumentScore - the output field header
  $meta - query operator
  textScore - to find the sorted query score for each matched token in ASC i.e. lowest match displayed first
  
----------------------------------------------
Collations in MongoDB ?
  Allows user to specify language specific rules for String comparison
  Such as, Letter comparison, accent marks
  
  {
   locale: <string>,
   caseLevel: <boolean>,
   caseFirst: <string>,
   strength: <int>,
   numericOrdering: <boolean>,
   alternate: <string>,
   maxVariable: <string>,
   backwards: <boolean>
}

locale	string	The ICU locale. See Supported Languages and Locales for a list of supported locales.
strength	integer	Optional. The level of comparison to perform.  

caseLevel	boolean	Optional. Flag that determines whether to include case comparison at strength level 1 or 2.
          If true, include case comparison; i.e.

          When used with strength:1, collation compares base characters and case.
          When used with strength:2, collation compares base characters, 
          diacritics (and possible other secondary differences) and case.
          If false, do not include case comparison at level 1 or 2. The default is false.  
  
  

caseFirst	string	Optional. A field that determines sort order of case differences during tertiary level comparisons.
                   “upper”	Uppercase sorts before lowercase.
                   “lower”	Lowercase sorts before uppercase.
                   “off”	Default value. Similar to "lower" 
                   
numericOrdering	boolean	Optional. Flag that determines whether to compare numeric strings as numbers or as strings.

                If true, compare as numbers; i.e. "10" is greater than "2".
                If false, compare as strings; i.e. "10" is less than "2".                   

alternate	string	Optional. Field that determines whether collation should consider
                       whitespace and punctuation as base characters for purposes of comparison.                   
                   
maxVariable	string	Optional. Field that determines up to which characters are considered 
                        ignorable when alternate: "shifted". Has no effect if alternate: "non-ignorable"                   
                   
backwards	boolean	Optional. Flag that determines whether strings with diacritics 
                    sort from back of the string, such as with some French dictionary ordering.                   
                   
normalization	boolean	Optional. Flag that determines whether to check if text require normalization 
                     and to perform normalization. Generally, majority of text 
                     does not require this normalization processing.                   
                   

Note: We can define a collation for the collection, which means all queries and indexes 
      in such collection will be using the associated collation
                   
Example of Collation on Collection:
  db.createCollation(
  {
   "collection_name", {
     collation : { locale : "en" } 
   }
  })

Example of Collation on Index :

  db.collection.createIndex({
    field1 : 1
  },
  {
    collation : {locale : "en"}
  }
  )
                   
Note: Index level collation has been overriden over the collection level collation defined                   
      The query must match collation of the index defined
      else, the created indexed won't be used
    Example, how to define the collation for the query
      db.collection.find({field1 : "value"}).collation({locale : "en"})
                                             
You cannot specify multiple collations for an operation. 
For example, you cannot specify different collations per field, 
or if performing a find with a sort, you cannot use one collation for the find and another for the sort.
