
Dependency Injection
. Constructor based
. Getter-Setter based dependecy inject

Configuration for dependecy Injection
. XML based
. Java code
. Annotations


Autowiring modes

Autowiring Mode	Description
byName	Autowiring based on bean name through setter injection
byType	Autowiring based on bean type through setter injection
constructor	Autowiring based on the bean type through parameterized constructor
no	No Autowiring, required dependency has to be injected explicitly using <property> or <constructor-arg> ref attribute in bean definition

----------------------

Inversion of Control (IoC) is a design principle (although, some people refer to it as a pattern). 
As the name suggests, it is used to invert different kinds of controls in object oriented design to achieve loose coupling. 
Here, the control means any additional responsibilities a class has other than its main responsibility, 
such as control over the flow of an application, 
control over the flow of an object creation or dependent object creation and binding.

----------------------
Application Context is Eager loading 
BeanFactory is lazy loading

BeanFactory doesn't support Enterprise services such as Internationalization, Validation
  whereas ApplicationContext supports Enterprise services
  
BeanFactory doesn't support annotations based whereas ApplicationContext supports annotations based configuration


dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. 
A dependency is an object that can be used (a service). 
An injection is the passing of a dependency to a dependent object (a client) that would use it.

----------------------

<bean id="" class="">
  <constructor-args 
    type - type of parameter [primitive are possible]
    index - 0 based index 
    value - value of the instance variable
    name - matching name with the instance varibale name in the class to be injected
    ref - reference of the other bean


-----------------------------

Autowiring feature of spring framework enables you to inject the object dependency implicitly. 
It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.

autowire="byName" : Autowiring using property name.
    If a bean found with same name as the property of other bean, this bean will be wired into other beans property
    
autowire="byType" : If a bean found with same type as the type of property of other bean, 
    this bean will be wired into other beans property

autowire="constructor" : If a bean found with same type as the constructor argument of other bean, 
    this bean will be wired into other bean constructor
    First byType and then byName

autowire="no" : No Autowiring. Same as explicitly specifying bean using ‘ref’ attribute

-----------------------------
<context:annotation-config/>

@Autowired default is byType should have Qualifier to resolve

@Autowired
@Qualifier("<BEAN_NAME>") 
The @Qualifier annotation is used to resolve the autowiring conflict, when there are multiple beans of same type.


<context:component-scan base-packages="..." />

-----------------------------

@Bean 
public T methodName() { ... }

The bean created would be name as method-name in class.


@Configuration & @Bean Annotations
Annotating a class with the @Configuration indicates that 
  the class can be used by the Spring IoC container as a source of bean definitions. 
  The @Bean annotation tells Spring that 
    a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. 
The simplest possible @Configuration class would be as follows −

-----------------------------

Spring AOP














