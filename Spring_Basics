
Dependency Injection
. Constructor based
. Getter-Setter based dependecy inject

Configuration for dependecy Injection
. XML based
. Java code
. Annotations


Autowiring modes

Autowiring Mode	Description
byName	Autowiring based on bean name through setter injection
byType	Autowiring based on bean type through setter injection
constructor	Autowiring based on the bean type through parameterized constructor
no	No Autowiring, required dependency has to be injected explicitly using <property> or <constructor-arg> ref attribute in bean definition

----------------------

Inversion of Control (IoC) is a design principle (although, some people refer to it as a pattern). 
As the name suggests, it is used to invert different kinds of controls in object oriented design to achieve loose coupling. 
Here, the control means any additional responsibilities a class has other than its main responsibility, 
such as control over the flow of an application, 
control over the flow of an object creation or dependent object creation and binding.

----------------------
Application Context is Eager loading 
BeanFactory is lazy loading

BeanFactory doesn't support Enterprise services such as Internationalization, Validation
  whereas ApplicationContext supports Enterprise services
  
BeanFactory doesn't support annotations based whereas ApplicationContext supports annotations based configuration


dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. 
A dependency is an object that can be used (a service). 
An injection is the passing of a dependency to a dependent object (a client) that would use it.

----------------------

<bean id="" class="">
  <constructor-args 
    type - type of parameter [primitive are possible]
    index - 0 based index 
    value - value of the instance variable
    name - matching name with the instance varibale name in the class to be injected
    ref - reference of the other bean


-----------------------------

Autowiring feature of spring framework enables you to inject the object dependency implicitly. 
It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.

autowire="byName" : Autowiring using property name.
    If a bean found with same name as the property of other bean, this bean will be wired into other beans property
    
autowire="byType" : If a bean found with same type as the type of property of other bean, 
    this bean will be wired into other beans property

autowire="constructor" : If a bean found with same type as the constructor argument of other bean, 
    this bean will be wired into other bean constructor
    First byType and then byName

autowire="no" : No Autowiring. Same as explicitly specifying bean using ‘ref’ attribute

-----------------------------
<context:annotation-config/>

@Autowired default is byType should have Qualifier to resolve

@Autowired
@Qualifier("<BEAN_NAME>") 
The @Qualifier annotation is used to resolve the autowiring conflict, when there are multiple beans of same type.


<context:component-scan base-packages="..." />

-----------------------------

@Bean 
public T methodName() { ... }

The bean created would be name as method-name in class.


@Configuration & @Bean Annotations
Annotating a class with the @Configuration indicates that 
  the class can be used by the Spring IoC container as a source of bean definitions. 
  The @Bean annotation tells Spring that 
    a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. 
The simplest possible @Configuration class would be as follows −

-----------------------------

Bean - An entity to instantiate Object 

@Controller, @Service, @Component, @Repository

Why autowire? - Exlicilty mentionning bean is not required

-----------------------------

Disadvantage of JDBC -
  1. Boiler plate code - to register driver, initiate a connection, Prepare statement, fetch result
  2. Handle checked Exception - 
  3. Iterate Resultset
  
-----------------------------

Spring JdbcTemplate is a powerful mechanism to connect to the database and execute SQL queries. 
It internally uses JDBC api, but eliminates a lot of problems of JDBC API.

Problems of JDBC API
The problems of JDBC API are as follows:

1) We need to write a lot of code before and after executing the query,
  such as creating connection, statement, closing resultset, connection etc.
  
2) We need to perform exception handling code on the database logic.

3) We need to handle transaction.
4) Repetition of all these codes from one to another database logic is a time consuming task.

Advantage of Spring JdbcTemplate
Spring JdbcTemplate eliminates all the above mentioned problems of JDBC API. 
It provides you methods to write the queries directly, so it saves a lot of work and time.


-----------------------------

<property name="hibernate.hbm2ddl.auto">create</property> will create tables. 
But it will not create database. Change the connection url to generate the database. create - 
It creates new tables corresponding mapping or annotation.

-----------------------------

private JDBCTemplate jdbcTemplate;

@Autowired
public void setJdbcTemplate(DataSource dataSource) {this.jdbcTemplate}

-----------------------------

1) jdbcTemplate.query - to fetch records from the database
 Eg. 
  List<T> query(sqlQuery, new RowMapper<T>(){ .... })

2) jdbcTemplate.update - for Create, Update, Delete operations
 Eg. 
 update(sqlQuery, new Object[]{})
 
 3) queryForXXX(sqlQuery, new Object[]{primaryKey})
    will return the object of the type we called in the form of Object class object
    
Object o1 = queryForObject(” select sysdate from dual “, Date.class) ;
Object o2 = queryForObject(” select salary from emp”, Integer.class);
Object o3 = queryForObject(” select empName from emp”,String.class);

Date d = (Date)o1;
Integer i = (Integer)o2;
String s = (String)o3;

-----------------------------

RowMapper -

RowMapper interface allows to map a row of the relations with the instance of user-defined class. 
It iterates the ResultSet internally and adds it into the collection. 
So we don't need to write a lot of code to fetch the records as ResultSetExtractor.

Advantage of RowMapper over ResultSetExtractor
RowMapper saves a lot of code becuase it internally adds the data of ResultSet into the collection.

Method of RowMapper interface
It defines only one method mapRow that accepts ResultSet instance and int as the parameter list. 

public T mapRow(ResultSet rs, int rowNumber)throws SQLException  

-----------------------------

Disadvantages of Spring JDBC -
  1. Spring JDBC is database dependent
  2. Developer should know the concept of RDBMS - as query to be provided by developer
  3. Problem of Granularity -  i.e. More or less number of Classes than number of tables
  4. Problem of Identity - Java uses equal method where as records are compared with primary key
  5. Problem of Subtype - Java has inheritance that is unavailable in RDBMS
  6. Problem of Navigation - Java uses composition easily but RDBMS has joins to fetch and concatenate data from tables 


-----------------------------

ORM - Object relational Mapping (Every class is going to be mapped to a table in database )
  . Class - Table
  . Object - Record
  . Attribute - Column
  
 Framworks - Hibernate, ibatis, toplink, eclipselink

-----------------------------

HIbernate ORM - 
SessionFactory -

Configuration object is used to create a SessionFactory object which in turn configures 
Hibernate for the application using the supplied configuration file and allows for a Session object to be instantiated.
The SessionFactory is a thread safe object and used by all the threads of an application.


1. sessionFactory.openSession()
2. session.beginTransaction()
3. transaction.commit() or transaction.rollback()
4. session.close()

-----------------------------

Dialect - specifies the format of query for the target database
hbm2ddl - Drop and autocreate tables
  validate: validate the schema, do not change happens to the database.
  update[default]: update the schema with currently execute query.
  create: creates new schema every time, and destroy previous data.
  create-drop: drop the schema when the application is stopped or SessionFactory is closed explicitly.


----------------------

EntityManagerFactory - this is Spring ORM JPA (as JPA is specification which is implemented by Other ORMs like Hibernate)
  There are multiple JPA providers which are implementing ORM.

EntityManger em = entityManagerFactory.createEntityManger();
 em.getTransaction().begin();
 ...
 // persist, save - to save
 // find - to look for Object
 // remove - to remove the Object
 
 em.getTransaction().commit();

<bean id="entityManagerFactory" ...
...
  <property name="jpaVendorName" ref="hbAdapterBean"/>
  ...
</bean>
 
<bean id="hbAdapterBean" class="...">
  ...
</bean>


----------------------

1.2 BeanPropertyRowMapper
In Spring 2.5, comes with a handy RowMapper implementation called ‘BeanPropertyRowMapper’,
which can maps a row’s column value to a property by matching their names.
Just make sure both the property and column has the same name, 
e.g property ‘custId’ will match to column name ‘CUSTID’ or with underscores ‘CUST_ID’.

public Customer findByCustomerId2(int custId){
		 
	String sql = "SELECT * FROM CUSTOMER WHERE CUST_ID = ?";
 
	Customer customer = (Customer)getJdbcTemplate().queryForObject(
			sql, new Object[] { custId }, 
			new BeanPropertyRowMapper(Customer.class));
	
	return customer;
}

----------------------

Spring JDBC -> JdbcTemplate interface accepts 
  - update method will be used for Create, delete, updated
  
Spring ORM hibernate ->
  dataSourceBean, sessionFactory beans are mandatiry
  packagesToScan -> The packages where @Entity is found
  
  SessionFactory (Autowired) -> Session Object -> openSession -> beginTransaction -> save,  -> commit -> session.close() 

Spring ORM JPA ->
  Beans: EntityMangerFactory, dataSource, jpaVendorAdapter, packagesToScan
  
  EntityManagerFactory -> EntityManger -> Transaction begin -> persist, remove -> Transaction commit

----------------------

When do we prefer Programmatic transaction and Declarative? 

----------------------

bean id="transactionManager" class="...DataSourceTransactionManager"

@Transactional - on a Method and a class

----------------------
Spring Data JPA - 

  1. Repository -> provide implementation by the framework
   public interface EmployeeRepository extends JpaRepository<Employee, Integer> { }
 
  Employee -> Entity
  Integer -> Primary Key type
  
  <jpa:repositories base-package="..." />
  
  Beans : dataSource, jpaVendorAdapter, entityManagerFactory (packagesToScan -> look for classes with @Entity)
  , transactionManager [transaction is built in part of framework, no such bean will throw exception]


----------------------

Class PageRequest
java.lang.Object
org.springframework.data.domain.AbstractPageRequest
org.springframework.data.domain.PageRequest
All Implemented Interfaces:
Serializable, Pageable

static PageRequest	of(int page, int size)
Creates a new unsorted PageRequest.

// properties define the variable list of Columns on which the Records should be sorted
static PageRequest	of(int page, int size, Sort.Direction direction, String... properties)
Creates a new PageRequest with sort direction and properties applied.

Pageable is an interface which contains requested page information. 
We can use it's implementation PageRequest which has various factory methods:

 PageRequest of(int page, int size)
Where: page - zero-based page index. 
size - the size of the page to be returned. 



================================
****************************
================================
Spring MVC -

   JSP has provided the JSTL (Tag libraries), where Views and Business logic was coupled
   
Solution!! -
  Some MVC framework - 
    Model: Data
    View: UI
    Controller -
    	Pre-process, business logic, view resolving...

BUT
  1) Coding of Controller is difficult, as it doesn't perform single responsibility
  2) Routing logic in Java file [changes require rebuilt]
  
  
----------------------

Spring MVC - 

Benefits - 
  1. A ready controller to be configured
  2. Navigation or Routing as a part of Configuration
  
  
Spring Web MVC is the original web framework built on the Servlet API and 
has been included in the Spring Framework from the very beginning. 
The formal name, “Spring Web MVC,” comes from the name of its source module (spring-webmvc), 
but it is more commonly known as “Spring MVC”.

























