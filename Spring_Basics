
Dependency Injection
. Constructor based
. Getter-Setter based dependecy inject

Configuration for dependecy Injection
. XML based
. Java code
. Annotations


Autowiring modes

Autowiring Mode	Description
byName	Autowiring based on bean name through setter injection
byType	Autowiring based on bean type through setter injection
constructor	Autowiring based on the bean type through parameterized constructor
no	No Autowiring, required dependency has to be injected explicitly using <property> or <constructor-arg> ref attribute in bean definition

----------------------

Inversion of Control (IoC) is a design principle (although, some people refer to it as a pattern). 
As the name suggests, it is used to invert different kinds of controls in object oriented design to achieve loose coupling. 
Here, the control means any additional responsibilities a class has other than its main responsibility, 
such as control over the flow of an application, 
control over the flow of an object creation or dependent object creation and binding.

----------------------
Application Context is Eager loading 
BeanFactory is lazy loading

BeanFactory doesn't support Enterprise services such as Internationalization, Validation
  whereas ApplicationContext supports Enterprise services
  
BeanFactory doesn't support annotations based whereas ApplicationContext supports annotations based configuration


dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. 
A dependency is an object that can be used (a service). 
An injection is the passing of a dependency to a dependent object (a client) that would use it.

----------------------

<bean id="" class="">
  <constructor-args 
    type - type of parameter [primitive are possible]
    index - 0 based index 
    value - value of the instance variable
    name - matching name with the instance varibale name in the class to be injected
    ref - reference of the other bean


-----------------------------

Autowiring feature of spring framework enables you to inject the object dependency implicitly. 
It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.

autowire="byName" : Autowiring using property name.
    If a bean found with same name as the property of other bean, this bean will be wired into other beans property
    
autowire="byType" : If a bean found with same type as the type of property of other bean, 
    this bean will be wired into other beans property

autowire="constructor" : If a bean found with same type as the constructor argument of other bean, 
    this bean will be wired into other bean constructor
    First byType and then byName

autowire="no" : No Autowiring. Same as explicitly specifying bean using ‘ref’ attribute

-----------------------------
<context:annotation-config/>

@Autowired default is byType should have Qualifier to resolve

@Autowired
@Qualifier("<BEAN_NAME>") 
The @Qualifier annotation is used to resolve the autowiring conflict, when there are multiple beans of same type.


<context:component-scan base-packages="..." />

-----------------------------

@Bean 
public T methodName() { ... }

The bean created would be name as method-name in class.


@Configuration & @Bean Annotations
Annotating a class with the @Configuration indicates that 
  the class can be used by the Spring IoC container as a source of bean definitions. 
  The @Bean annotation tells Spring that 
    a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. 
The simplest possible @Configuration class would be as follows −

-----------------------------

Bean - An entity to instantiate Object 

@Controller, @Service, @Component, @Repository

Why autowire? - Exlicilty mentionning bean is not required

-----------------------------

Disadvantage of JDBC -
  1. Boiler plate code - to register driver, initiate a connection, Prepare statement, fetch result
  2. Handle checked Exception - 
  3. Iterate Resultset
  
-----------------------------

Spring JdbcTemplate is a powerful mechanism to connect to the database and execute SQL queries. 
It internally uses JDBC api, but eliminates a lot of problems of JDBC API.

Problems of JDBC API
The problems of JDBC API are as follows:

1) We need to write a lot of code before and after executing the query,
  such as creating connection, statement, closing resultset, connection etc.
  
2) We need to perform exception handling code on the database logic.

3) We need to handle transaction.
4) Repetition of all these codes from one to another database logic is a time consuming task.

Advantage of Spring JdbcTemplate
Spring JdbcTemplate eliminates all the above mentioned problems of JDBC API. 
It provides you methods to write the queries directly, so it saves a lot of work and time.


-----------------------------

<property name="hibernate.hbm2ddl.auto">create</property> will create tables. 
But it will not create database. Change the connection url to generate the database. create - 
It creates new tables corresponding mapping or annotation.

-----------------------------

private JDBCTemplate jdbcTemplate;

@Autowired
public void setJdbcTemplate(DataSource dataSource) {this.jdbcTemplate}

-----------------------------

1) jdbcTemplate.query - to fetch records from the database
 Eg. 
  List<T> query(sqlQuery, new RowMapper<T>(){ .... })

2) jdbcTemplate.update - for Create, Update, Delete operations
 Eg. 
 update(sqlQuery, new Object[]{})
 
 3) queryForXXX(sqlQuery, new Object[]{primaryKey})
    will return the object of the type we called in the form of Object class object
    
Object o1 = queryForObject(” select sysdate from dual “, Date.class) ;
Object o2 = queryForObject(” select salary from emp”, Integer.class);
Object o3 = queryForObject(” select empName from emp”,String.class);

Date d = (Date)o1;
Integer i = (Integer)o2;
String s = (String)o3;

-----------------------------

RowMapper -

RowMapper interface allows to map a row of the relations with the instance of user-defined class. 
It iterates the ResultSet internally and adds it into the collection. 
So we don't need to write a lot of code to fetch the records as ResultSetExtractor.

Advantage of RowMapper over ResultSetExtractor
RowMapper saves a lot of code becuase it internally adds the data of ResultSet into the collection.

Method of RowMapper interface
It defines only one method mapRow that accepts ResultSet instance and int as the parameter list. 

public T mapRow(ResultSet rs, int rowNumber)throws SQLException  

-----------------------------

Disadvantages of Spring JDBC -
  1. Spring JDBC is database dependent
  2. Developer should know the concept of RDBMS - as query to be provided by developer
  3. Problem of Granularity -  i.e. More or less number of Classes than number of tables
  4. Problem of Identity - Java uses equal method where as records are compared with primary key
  5. Problem of Subtype - Java has inheritance that is unavailable in RDBMS
  6. Problem of Navigation - Java uses composition easily but RDBMS has joins to fetch and concatenate data from tables 


-----------------------------

ORM - Object relational Mapping (Every class is going to be mapped to a table in database )
  . Class - Table
  . Object - Record
  . Attribute - Column
  
 Framworks - Hibernate, ibatis, toplink, eclipselink

-----------------------------

SessionFactory -

Configuration object is used to create a SessionFactory object which in turn configures 
Hibernate for the application using the supplied configuration file and allows for a Session object to be instantiated.
The SessionFactory is a thread safe object and used by all the threads of an application.


1. sessionFactory.openSession()
2. session.beginTransaction()
3. transaction.commit() or transaction.rollback()
4. session.close()

-----------------------------

Dialect - specifies the format of query for the target database
hbm2ddl - Drop and autocreate tables
  validate: validate the schema, do not change happens to the database.
  update[default]: update the schema with currently execute query.
  create: creates new schema every time, and destroy previous data.
  create-drop: drop the schema when the application is stopped or SessionFactory is closed explicitly.
























